#!/usr/bin/python3
# 
# Originally taken from:
# tibtle2pcap: Read a Bluetooth Low Energy packet capture savefile generated by
# the TI Packet Sniffer utility (.psd file, but not PhotoShop), and convert it
# to a libpcap packet capture file.  The libpcap packet capture file is formatted
# to use the PPI DLT, with DLT_USER set so the BTLE Wireshark plugin can be used
# to decode the BTLE traffic.
#
# You can download the SmartRF Packet Sniffer software here:
#    http://www.ti.com/tool/packet-sniffer
# The CC2540 USB Evaluation Kit USB dongle that captures Bluetooth LE
# traffic (and injects) with default firmware is available from digikey.com
# and many other sites for $50 with the part number CC2540EMK-USB.
#
# Many thanks to Mike Ryan for blazing the path forward to open up Bluetooth LE
# sniffing and traffic analysis.
# Joshua Wright, 2014-03-03 

import struct
import sys
# import pcapdump
import hexdump
import binascii
import numpy as np
import mat4py as m4p

TIRECLEN = 271  # Texas Instrument Recorded Length
DLT_PPI = 192
packets = []
rssi_val = []
time = []
true_packets = []

def chan2mhz(chan):  # given a channel, the associated frequency is provided as result.
    chanmap = {
        37: 2402, 0: 2404, 1: 2406, 2: 2408, 3: 2410, 4: 2412, 5: 2414, 6: 2416, 7: 2418,
        8: 2420, 9: 2422, 10: 2424, 38: 2426, 11: 2428, 12: 2430, 13: 2432, 14: 2434, 15: 2436,
        16: 2438, 17: 2440, 18: 2442, 19: 2444, 20: 2446, 21: 2448, 22: 2450, 23: 2452, 24: 2454,
        25: 2456, 26: 2458, 27: 2460, 28: 2462, 29: 2464, 30: 2466, 31: 2468, 32: 2470, 33: 2472,
        34: 2474, 35: 2476, 36: 2478, 39: 2480}
    try:
        return chanmap[chan]
    except IndexError:
        return 0


# if len(sys.argv) < 2:
# 	print ("x-ti-psd2txt.py [TI psd file]")
# 	sys.exit(1)

# capfile = open(sys.argv[1], "rb") #r = read; b = binary
capfile = open("Relay3s_150cm.psd", "rb")  # open the file
capturedata = capfile.read()  # read all the file
capfile.close()  # close the file

for i in range(0, len(capturedata), TIRECLEN):
    packets.append(capturedata[i:i + TIRECLEN])

# for i = 0 to i = length caputerdata, with a TIRECLEN step create the packets list

# +----------------------------------------------------+----------------- - - -
# |     Packet sniffer frame header                    |
# +----+-------------+-------------------------+-------+
# |info| Packet nbr. | Time stamp              | Length|  Packet data
# +----+-------------+-------------------------+-------+----------------- - - -
# | 01 | 01 00 00 00 | 71 05 8C 01 00 00 00 00 | 27 00 | 26 D6 BE 89 8E 00 1B C6 89 1D E6 68 B0 02 01 1A 11 07 FC 9D D0 B3 CB 84 E0 84 06 42 F3 F7 E1 E0 BF CB C2 7A F4 12 A5
# +----+-------------+-------------------------+-------+----------------- - - -

# struct.unpack('<cidh' ... "<" = little endian; "c" = char(1); "i" = int(4); "d" = double(8); "h" = short(2); "Q" uns long long int(8)
tbase = 0
temp_counter = 0  # temp counter to stop reading packets
print("NUMERO PACCHETTI: ",len(packets))
for packet in packets:
    temp_counter += 1
    print("[{}] -> {}".format(temp_counter, binascii.hexlify(packet)))

    # primo unpacking, livello PacketSniffer psd
    (pinfo, pnum, pts, plen) = struct.unpack('<ciQh', packet[0:15])
    # c - char = 8 bit (1 byte) -> pinfo
    # i - int = 4 byte -> packet number
    # Q - unsigned long long (int) = 8 bytes -> timestamp
    # h - short (int) = 2 bytes -> packet length

    # for Format Characters info here: https://docs.python.org/3/library/struct.html#struct.unpack

    print("pinfo = {}".format(pinfo))
    print("pnum = {}".format(pnum))
    print("pts (timestamp-decimal) = {}".format(pts))
    print("plen = {}".format(plen))

    # temp exit, remove to parse all file
    # if (temp_counter > 9):
        # sys.exit(0)  # dopo dieci pacchetti si blocca

    if pinfo != b'\x01': continue  # dovrebbero essere tutti 0x01

    # prendo il timestamp "base"
    if pnum == 1: tbase = pts

    # if ((pnum > 3) & (pnum != 432)): continue

    # ptsus = (int)pts/419428,4 #in microsec
    data = packet[15:15 + plen]
    payload = data[0:-2]

    # DBG prints
    print("here")
    print("data (hex) = {}".format(binascii.hexlify(data)))
    print("payload (hex) = {}".format(binascii.hexlify(payload)))

    # Based on my analysis of the TI Packet Sniffer savefile, we can get these
    # additional values too.  When the PPI format is updated to accommodate non-802.11
    # types, we can add them.

    # DA QUI IN POI RIVERIFICARE TUTTO... (verificato)
    rssi_fcs = data[-2:]  # last two elements of the data

    # the first one is the rssi, while the second is divided into:
    # [ - - - - - - -] (0-6) 7 bit for the channel number
    # last bit for CRC OK or NOT OK

    print("rssi_fcs (hex) = {}".format(binascii.hexlify(rssi_fcs)))

    rssi = rssi_fcs[0] - 94
    # rssi_val.append(rssi)
    exflags = rssi_fcs[1]  # last byte

    print("rssi = {}".format(rssi))

    # rssi = ord(data[-2:-1])-94
    # exflags = ord(data[-2:-1])
    # exflags = ord(data[-1])
    channel = exflags & 0x7f  # masking with 0111 1111 (bit 0-6 for channel number)
    fcsok = (exflags & 0x80 > 0)  # masking with 1000 0000 (bit 7 for crc ok or not)

    print("channel number = {}".format(channel))
    print("CRC OK = {}".format(fcsok))

    # last 2 bytes of the data have been analyzed.
    # let's start with the payload decomposition:

    (ble_pre, ble_aa) = struct.unpack('<cI', payload[0:5])
    ble_pdu = payload[5:-3]
    # il ble_pdu has 2 byte for BLE HEADER and the others are the payload
    ble_crc = payload[-3:]
    ble_pre = hex(int.from_bytes(ble_pre, byteorder='big'))  # FROM BYTE TO INT AND AFTER FROM INT TO HEX
    print("ble_pre (hex) = ", ble_pre)
    print("acc_addr (decimal) = {}".format(ble_aa))  # IN DECIMAL
    # print ("ble_pdu = ",''.join('{:02X}'.format(ord(x)) for x in ble_pdu))
    # print ("ble_crc = ",''.join('{:02X}'.format(ord(x)) for x in ble_crc[3::-1]))
    # my version:
    print("ble_pdu (hex) = {}".format(binascii.hexlify(ble_pdu)))
    print("ble_crc (hex) = {}".format(binascii.hexlify(ble_crc)))

    pdu_head = ble_pdu[0:2]  # first 2 payload bytes are for BLE HEADER
    pdu_payload = ble_pdu[2:]  # others are for ...? INDAGARE

    # print ("pdu_head = ",''.join('{:02X}'.format(ord(x)) for x in pdu_head))
    # print ("pdu_payload = ",''.join('{:02X}'.format(ord(x)) for x in pdu_payload))
    print("pdu_header (hex) = {}".format(binascii.hexlify(pdu_head)))
    print("pdu_payload (hex) = {}".format(binascii.hexlify(pdu_payload)))

    pdu_pl_len0 = len(pdu_payload)
    print("pdu_pl_len0", pdu_pl_len0)
    '''
	FURTHER ANALYSIS ON DATA PACKETS
	
	DOCUMENTATION HERE: https://www.mdpi.com/1424-8220/12/9/11734
	
	ARTICLE:
	Gomez, Carles, Joaquim Oller, and Josep Paradells.
	"Overview and evaluation of bluetooth low energy: An emerging low-power wireless technology."
	Sensors 12.9 (2012): 11734-11753.

	MIC = pdu_payload[-4:] #Message Integrity Check (4 bytes)
	L2HE = pdu_payload[0:4] #L2CAP HEADER (4 bytes)
	Op = pdu_payload[5] #ATT Opcode (1 byte)
	par_pay = pdu_payload[5:-4] #parameters and payload <= 22 bytes
	print("----------- par/pay length: ", len(par_pay))
	'''

    # *-*-*-*- ADVERTISING PACKETS ANALYSIS (OUR INTEREST):
    # info here: https://www.bluetooth.com/blog/bluetooth-low-energy-it-starts-with-advertising/

    # 2 BYTE HEADER decomposition:
    # RxAdd (1 bit) | TxAdd (1 bit) | RFU (2 bit)  | Tipo PDU (4 bit) | RFU (2 bit) | Lunghezza (6 bit)
    RXrnd = ((pdu_head[0] & 0x80) > 0)
    TXrnd = ((pdu_head[0] & 0x40) > 0)
    pdu_type = pdu_head[0] & 0x0F
    pdu_pl_len = pdu_head[1] & 0x3F
    print("TXrnd", TXrnd)
    print("RXrnd", RXrnd)
    print("pdu_type = {}".format(pdu_type))
    # print("pdu type =",pdu_type) questo Ã¨ uguale a sopra
    print("pdu_pl_len = {}".format(pdu_pl_len))

    if (pdu_pl_len0 != pdu_pl_len): continue

    adv_addr = pdu_payload[0:6]
    adv_data = pdu_payload[6:]
    adv_data_int = int.from_bytes(adv_data, byteorder='big')
    print("ADV_DATA_INT: ",adv_data_int)
    if adv_data_int != 568077315973163214883225200891060792043881845638932060292:
        print("ECCOMI")
        time.append((pts - tbase) / 419428.4)
        rssi_val.append(rssi)
    print("adv_addr (MAC address on nRF CONNECT APP) = 0x",
          ''.join('{:02X}'.format(x) for x in adv_addr[::-1]))  # for che legge tutta la lista al contrario
    print("adv_data = 0x", ''.join('{:02X}'.format(x) for x in adv_data))

    #                    "{:.3f}".format(pts/419428,4)
    # print "Packet",pnum,"ts","{:.3f}".format((pts-tbase)/419428.4),"RSSI",rssi,"Channel",channel,"FCSOK",fcsok
    print("Packet", pnum, "ts", "{:.3f}".format((pts - tbase) / 419428.4), "ble_preamble", ble_pre, "Acc_addr",
          ("0x%08X" % ble_aa), "RSSI", rssi, "Channel", channel, "FCSOK", fcsok)
    print("\n")
    # print pnum,pts
    hexdump.hexdump(data)
    print("\n\n")
    # time.append((pts - tbase) / 419428.4)
# This hideoous string is a PPI header with DLT_USER specified so we can use
# the btle plugin with Wireshark.
# pd.pcap_dump("\x00\x00\x08\x00\x93\x00\x00\x00" + payload)
print("\n")
print("relay3s_150cm\n")
print("RSSI mean: ", np.mean(rssi_val))
print("RSSI variance: ", np.var(rssi_val))
print("Received packets: ", len(packets))
print("Losses probability: ",(200-len(packets))/2,"%")
print(rssi_val)
print(len(rssi_val))
print(time)
print(len(time))